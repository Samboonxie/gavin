Введение (основано на комментариях Gavin'а)
-------------------------------------------
Это 32-битная мультизадачная графическая операционная система для x86-компьютеров,
с файловой системой, поддержкой загрузки и исполнения пользовательских программ
в формате ELF, с драйверами PS/2 мыши и клавиатуры и с графикой VESA. И с командной
оболочкой. И с приложением - простым просмотрщиком файлов.

ОС построена на основе традиционного монолитного ядра с одной точкой входа для
системных вызовов. Приложения используют корпоративную многозадачность. Им можно
отправлять различные сообщения (например, "инициализироваться", "нажатие клавиши",
"отрисовать в буфер") через точку входа и они вернут управление системе, когда
выполнят нужную работу. Приложению передаётся указатель на его структуру задачи,
которая частично задана системой, и частично оставлена для использования самим
приложением.

Это программа компилируется в утилиту, которая генерирует образ ядра, то есть программа собирается,
Makefile запускает её, перенаправляя вывод в файл под названием `kernel`.
Затем Makefile соберёт корневую файловую систему - tar-файл (файловая система, поддерживаемая ОС - это tar).
ком многочисленны, чтобы их перечислять.

Если мышь выходит за левый край экрана, она выходит справа, и наоборот.
Если она выходит за верхний или нижний край, её ничто не остановит и она испортит память.

Файловая система в некотором роде оптимистична, например, если набрать `shell` в
командной строке, то запустится программа `sh`: считается, что `sh` - это то же,
что и `shell`.

ELF'ы загружаются на некорректные адреса, и их точка входа должна быть началом текстового
сегмента.

Драйвер клавиатуры работает только с основными алфавитно-цифровыми клавишами,
но не с такими, как `Shift` или `Backspace`.

В просмотрщике файлов (`vi`), клавиши Вверх/Вниз и PgUp/PgDown прокручивают по одной
строке или по одному экрану. Вас ничто не остановит от прокручивания выше верха файла. Нажатие других клавиш
может иметь непредсказуемый эффект.

x86 раскручивается в 32-битный режим за 6 инструкций, ещё за 4 устанавливаются сегменты
данных и стека и указатель на стек, что позволяет запустить код на Си. Кроме этого,
есть около десятка инструкций для переключения в графический режим. В общем, этого
достаточно мало по сравнению с размером Си-программы. Также, строка в основном
состоит из данных - заголовок ядра в стиле Linux'а для загрузчика, таблицы дескрипторов
защищённого режима, раскладки клавиатуры, и так далее.
(Также должен отметить, что строка содержит минифункции для выполнения x86-инструкций
`in` и `out` - чтобы работать с мышью и клавиатурой из Си-кода).

Портирование на другую архитектуру должно быть отностильно простым* - просто нужно
заменить строку на содержащую данные и код, подходящие для новой платформы.
Доступ к данным осуществляется относительно макроса `START` - так что его можно заменить
при необходимости (`0x90200` - это адрес, по которому загрузчик Linux'а загружает
образ x86-ядра).

* ;-)


Ядро и файловая система
-----------------------
ОС состоит из 2 компонентов:

* Ядро
* Файловая система

ОС поддерживает только один тип файловой системы: архив tar, который загружается как initramfs. Gavin не имеет доступа к жёсткому диску.
Ядро находится в файле `kernel`, файловая система - в `fs.tar`. `fs.tar` содержит `sh` (командный интерпретатор), `vi` (текстовый просмотрщик), `prim` (генератор простых чисел) и несколько текстовых файлов, которые можно смотреть с помощью `vi`.

Сперва ОС имела только один исходный файл - `prog.c`. Затем жюри IOCCC переименовала его в `gavin.c`. Потом он был разделён на 4 файла:

* `common.c` и `common.h` - общий код
* `mkkernel.c` - ядро
* `user.h` и `user.c` - общий код для пользовательских приложений
* `sh.c` - оболочка
* `vi.c` - просмотрищик файлов
* `prim.c` - генератор простых чисел

Вот стадии сборки Gavin'а:

* `cc -c common.c`
* `cc -c mkkernel.c`
* `cc -c user.c`
* `cc -c sh.c`
* `cc -c vi.c`
* `cc -c prim.c`

* `cc -o mkkernel mkkernel.c common.o`. Теперь `mkkernel` - это обычное приложение GNU/Linux. Оно зависит от libc
* `./mkkernel > kernel`. Теперь `kernel` - это ядро Gavin'а
* `ld -s -o sh sh.o user.o common.o`. Теперь `sh` - это приложение Gavin'а. Оно не зависит от libc
* `ld -s -o vi vi.o user.o common.o`.
* `ld -s -o prim prim.o user.o common.o`.
* `tar -cf fs.tar sh vi prim ...`

Точкой входа `mkkernel`, естественно, является `_start` (который находится в libc). `_start` делает некоторую инициализацию, например, он открывает `stdout`. Затем он вызывает `main` (`main` находится в `mkkernel.c`).
`main` проверяет условие `argc == 0`. Если `argc != 0`, мы в GNU/Linux. В этом случае мы пишем код ядра в `stdout`. Сначала мы пришем некоторый машинный и другие данные, которые находятся в строке под названием "huge string". Затем мы пишем код `mkkernel` напрямую из памяти. Таким образом, `kernel` будет содержать большой кусок кода из `mkkernel`. Это означает, что `kernel` будет содержать ту же самую функцию `main`.

Предположим, что мы загрузились в ядро. Сперва ядро выполняет машинный код. Затем оно выполняет код из `main` (теперь точкой входа в Си-код является `main`, а не `_start`). И оно снова проверяет условие `argc == 0`. Но сейчас мы на реальном железе, поэтому `argc` действительно равно нулю. Поэтому мы выполним сценарий загрузки ядра.

`START` - это адрес, по которому загрузчик Linux'а загружает ядро. Поэтому мы можем читать "huge string" при помощи выражений вида `*(char *)(START + 131)`.


А теперь читайте английскую документацию :)
